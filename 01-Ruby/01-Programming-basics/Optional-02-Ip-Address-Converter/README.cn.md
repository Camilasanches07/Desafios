<!-- Please put your translation here and with the same style in README.md -->
## 背景与目标

这是为最快的你所准备的另一个编程套路（code kata）。我们想用不同的符号来处理数字，在这个例子中我们将讨论一下IPv4地址。

你可能已经见过一些IPv4地址了，例如`192.168.0.1`，或者`173.194.40.200`。你可以用`host` 命令来得到一个域名的IP地址。例如：

```bash
host www.lewagon.com
```

你将看到`www.lewagon.com`是一个映射到特定地址的Heroku域名的别名。

现在你可能想找到自己的IP地址？你的电脑拥有一个由WiFi路由器提供的IP地址，你可以通过在终端中键入“ips”得到该地址。你和其他同学共享着一个IP地址，如果想确定这个WiFi路由器的公共IP地址，你可以键入`myip`。

```bash
myip
```

这些命令并不是标准的，你能使用它们得感谢我们第一天进行的设置。例如，你可以用Sublime Text打开`~/.aliases`文件来浏览这些别名。

## 详细说明

一个IPv4地址是一个32位（32-bit）数字，它可用于识别互联网上的设备。
虽然计算机将IP地址读写为32位数字，但我们更喜欢以点号分隔的十进制记法来读取它们。这基本上是8位（8-bit）数字分成4块，转换为十进制，并用点号分隔开。

在这个套路（kata）中，你将创建`ip_to_num` 函数，它需要将一个IP地址字符串转化成一个数字；以及一个`num_to_ip`函数，它需要将一个数字转化为IP地址字符串。

这就是我们在二进制中表示 8位 的方式：

```ruby
00000000
# => 0

11111111
# => 255
```

我们怎样把二进制转化为十进制呢？这将用到2的指数。

```ruby
2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
```

所以一个32位IP地址应该是：
```ruby
00000000.00000000.00000000.00000000
# => 0.0.0.0
11111111.11111111.11111111.11111111
# => 255.255.255.255
```

例如：

如果我们以`37.160.113.170`为例。
我们必须以第一个8位开始：`37`.
我可以从`37`中分离出`128`吗？不能，所以我们把`0`赋予`128`。

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |
```
我可以从`37` 中分离出`64`吗?不能，所以我们把`0`赋予`64`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0
```
我可以从`37`中分离出`32`吗？可以，所以我们把`1`赋予`32`，且我们的余数现在是5.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |
```
我可以从`5`中分离出`16`吗？不能，所以我们把`0`赋予`16`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |   0 |
```
我可以从`5`中分离出`8`吗？不能，所以我们把`0`赋予`8`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |
```
我可以从`5`中分离出`4`吗？可以，所以我们把`1`赋予`4`，且我们的余数现在是`1`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |
```
我可以从`1`中分离出`2`吗？不能，所以我们把`0`赋予`2`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |  0  |
```
我们可以从`1`中分离出`1`吗？可以，所以我们把`1`赋予`1`，且我们的余数是`0`.

```ruby
128 |  64 |  32 |  16 |  8  |  4  |  2  |  1  |
 0  |  0  |   1 |  0  |  0  |  1  |  0  |  1  |
```
- 所以`37`在二进制中是`00100101`！（`32 + 4 + 1`）。
对其它3个八位（8-bit）数字重复上述步骤，你将得到完整的二进制IP。

- `160`的二进制是`10100000`! (`128 + 32`).
- `113`的二进制是`01110001`! (`64 + 32 + 16 + 1`).
- `170`的二进制是`10101010`! (`128 + 32 + 8 + 2`).

移除`.`就得到`00100101101000000111000110101010`，并将你的方法（method）应用于：`536870912 (2^29) + 67108864 (2^26) + 16777216 (2^24) + 8388608 (2^23) + 2097152 (2^21) + 16384 (2^14) + 8192 (2^13) + 4096 (2^12) + 256 (2^8) + 128 (2^7) + 32 (2^5) + 8 (2^3) + 2 (2^1)  = 631271850`.

所以```631271850```是IP地址```37.160.113.170```的十进制数字。
